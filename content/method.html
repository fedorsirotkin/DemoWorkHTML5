<!DOCTYPE html>
<html lang="ru-RU">
    <head>
        <meta charset="UTF-8">
        <!-- <link rel="stylesheet" href="css/style.css" type="text/css"/> -->
        <link rel="stylesheet" href="css/style.css">
        <!-- <script src="js/script.js" type="text/javascript"></script> -->
        <script src="js/script.js"></script>
        <title>Обзор методологий веб-разработки | Методологии и инструменты веб-разработки</title>
    </head>
    <body>
        <header>
            <div align="right"><a href="../content.html">Перейти к содержанию</a></div>
            <h1 align="center">Обзор методологий веб-разработки</h1>
        </header>
        <section>
            <h2 id="part1">БЭМ</h2>
        </section>
        <article contenteditable>
            <figure>
                <img src="../images/bem.png" width="480" height="287" alt="">
                <figcaption><font size="4"><i>Рисунок 1 - <b>Яндекс.БЭМ</b></i></font></figcaption>
            </figure>

            <p> 
                <font size="4">
                Пожалуй, самая популярная сейчас методология в мире. Название означает «<b>Блок</b>, <b>элемент</b>, <b>модификатор</b>».
                </font>
            </p>
            <p> 
                <font size="4">
                Эти категории играют следующие роли в коде:
                </font>
            </p>

            <ul>
                <li><font size="4"><b>блоки</b> могут использоваться в нескольких местах сайта;</font>  </li>
                <li><font size="4"><b>элементы</b> являются частью блока и не имеют функционального смысла вне блока;</font>  </li>
                <li><font size="4"><b>модификаторы</b> представляют собой свойства блока или элемента, которые меняют его внешний вид или поведение</font>.</li>
            </ul>
            <p> 
                <font size="4">
                Из этих категорий строятся классы для непосредственного использования в CSS. При этом не следует использовать селекторы тэгов (это потенциально может помешать использовать блок/элемент в каком-то нестандартном месте на сайте, т.е. привязывает сущность к контексту); рекомендуется также избегать каскадных селекторов, т.к. получившийся класс сам по себе достаточно точно (специфично) выбирает соответствующий элемент.
                </font>
            </p>
            <p> 
                <font size="4">
                Такой подход позволяет избавиться от непредсказуемых последствий каскада и изолирует отдельные модули друг от друга.
                </font>
            </p>
            <p> 
                <font size="4">
                Пример кода в стиле БЭМ:
                </font>
            </p>

            <pre>
                <font size="4">
                .block_element {...}
                .block_element-modifier {...}
                </font>
            </pre>
            <p> 
                <font size="4">
                Для удобства используются разные разделители между блоком и элементом и между блоком/элементом и модификатором; при этом можно использовать любые разделители, однако они должны быть одинаковыми в рамках одного проекта.
                </font>
            </p>
            <p> 
                <font size="4">
                А теперь о бочках меда и ложках дегтя:
                </font>
            </p>
            <p> 
                <font size="4">
                <b>Хорошо:</b> изолированность модулей друг от друга и отсутствие непредсказуемых каскадов селекторов.
                </font>
            </p>
            <p> 
                <font size="4">
                <b>Плохо:</b> не всегда длинные названия классов удобны для использования (для крупных проектов есть смысл использовать инструменты, автоматизирующие работу с БЭМ-разметкой).
                </font>
            </p>
            <p> 
                <font size="4">
                Кстати, для написания кода в таком стиле раньше часто рекомендовали препроцессор Stylus, так как он позволяет писать код так:
                </font>
            </p>
            <pre>
                <font size="4">
                .block {
                    &-element {...}
                }
                </font>
            </pre>
            <p> 
                <font size="4">
                Сейчас так можно писать, используя как SASS, так и LESS.
                </font>
            </p>
            <p> 
                <font size="4">
                И еще одно замечание — в оригинальной методологии БЭМ используются названия модификаторов, содержащие саму модифицируемую величину, например, button--sizeLarge. Сейчас в небольших проектах многие разработчики не указывают ее для лаконичности: button--large.
                </font>
            </p>
            <figure>
                <img src="../images/bemtwo.png" width="500" height="200" alt="">
                <figcaption><font size="4"><i>Рисунок 2 - <b>Яндекс.БЭМ. Пример блока</b></i></font></figcaption>
            </figure>
        </article>
        <section>
            <h2 id="part2">OOCSS</h2>
        </section>
        <article contenteditable>
            <figure>
                <img src="../images/oocss.png" width="500" height="200" alt="">
                <figcaption><font size="4"><i>Рисунок 3 - <b>OOCSS</b></i></font></figcaption>
            </figure>
            <p> 
                <font size="4">
                OOCSS означает объектно-ориентированный CSS (Object-Oriented CSS). В этот подход заложены две основные идеи:
                </font>
            </p>
            <ul>
                <li><font size="4">Разделение структуры и оформления</font></li>
                <li><font size="4">Разделение контейнера и контента (содержимого)</font></li>
            </ul> 
            <p> 
                <font size="4">
                Итак, «разделяй и властвуй». С помощью такой структуры разработчик получает общие классы, которые можно использовать в разных местах.
                </font>
            </p>
            <p> 
                <font size="4">
                А теперь — две новости (как водится, хорошая и плохая):
                </font>
            </p>
            <ul>
                <li><font size="4"><b>Хорошая</b>: уменьшение количества кода за счет повторного его использования (принцип DRY).</font></li>
                <li><font size="4"><b>Плохая</b>: достаточно сложная поддержка: при изменении стиля конкретного элемента скорее всего придется менять не только CSS (т.к. большинство классов общие), но и добавлять классы в разметку.</font></li>
            </ul>
            <p> 
                <font size="4">
                Кроме того, сам подход OOCSS предлагает не конкретные правила, а абстрактные рекомендации, поэтому метод достаточно сложен для применения на практике. 
                </font>
            </p>
            <p> 
                <font size="4">
                Зато, как это иногда случается, некоторые идеи OOCSS вдохновили авторов на создание своих, более конкретных, способов структурирования кода — своеобразных форков OOCSS.
                </font>
            </p>
        </article>
        <section>
            <h2 id="part3">SMACSS</h2>
        </section>
        <article contenteditable>
            <p> 
                <font size="4">
                SMACSS расшифровывается как «масштабируемая и модульная архитектура для CSS» (Scalable and Modular Architecture for CSS). 

                </font>
            </p>
            <p> 
                <font size="4">
                Основная цель подхода — уменьшение количества кода и на упрощение поддержки кода. 
                </font>
            </p>
            <p> 
                <font size="4">
                Итак, Джонатан предложил разделить стили на 5 частей (в порядке включения их в документ):
                </font>
            </p>
            <ul>
                <li><font size="4"><b>Base rules</b> — базовые стили. Это стили основных элементов сайта — body, input, button, ul, ol и т.п. В этой секции используются в основном селекторы тэгов и атрибутов, классы — в исключительных случаях (например, если у вас стилизованные JavaScript’ом селекты);</font></li>
                <li><font size="4"><b>Layout rules</b> — стили макета. Здесь находятся стили глобальных элементов размеры шапки, футера, сайдбара и т.п. Джонатан предлагает использовать здесь id в селекторах, так как эти элементы не будут встречаться более 1 раза на странице. Однако автор статьи считает это плохой практикой (каждый раз, когда в стилях появляется id селектор, где-то в мире грустит котенок). Используйте классы и будет вам счастье.</font></li>
                <li><font size="4"><b>Modules rules</b> — стили модулей, то есть блоков, которые могут использоваться несколько раз на одной странице. Для классов модулей не рекомендуется использовать id и селекторы тэгов (для многократного использования и независимости от контекста соответственно).</font></li>
                <li><font size="4"><b>State rules</b> — стили состояния. В этом разделе прописываются различные состояния модулей и скелета сайта. Это единственный раздел, в котором допустимо использование ключевого слова «!important».</font></li>
                <li><font size="4"><b>Theme rules</b> — оформление. Здесь описываются стили оформлений, которые со временем, возможно, нужно будет заменить (так удобно делать, например, новогоднее оформление; для html-тем, выставленных на продажу такие стили позволяют переключать цветовую гамму и т.п.).</font></li>
            </ul> 
            <p> 
                <font size="4">
                Также рекомендуется вводить неймспейсы для классов, принадлежащих к определенной группе, а также использовать отдельный неймспейс для классов, используемых в JavaScript.
                </font>
            </p>
            <p> 
                <font size="4">
                Этот подход действительно позволяет упростить написание и поддержку кода и в последнее время привлекает достаточно большое количество разработчиков.
                </font>
            </p>
            <figure>
                <img src="../images/smacss.png" width="500" height="200" alt="">
                <figcaption><font size="4"><i>Рисунок 4 - <b>SMACSS</b></i></font></figcaption>
            </figure>
        </article>
        <section>
            <h2 id="part4">Atomic CSS</h2>
        </section>
        <article contenteditable>
            <p> 
                <font size="4">
                Atomic CSS, редко также ACSS — атомарный CSS. В некотором роде этот подход представляет собой OOCSS, возведенный в абсолют. 
                </font>
            </p>
            <p> 
                <font size="4">
                При использовании такого подхода для каждого повторно используемого свойства должен быть сформирован отдельный класс. Пример: стиль «margin-top: 1px» предполагает создание класса «mt-1», стиль «width: 200px» создание класса «w-200». 
                </font>
            </p>
            <p> 
                <font size="4">
                Такой стиль позволяет минимизировать объем CSS-кода за счет повторного использования деклараций, а также сравнительно легко вводить изменения в модули, к примеру, при изменении технического задания.
                </font>
            </p>
            <p> 
                <font size="4">
                Однако у этого подхода есть существенные недостатки! Вот они:
                </font>
            </p>
            <ul>
                <li><font size="4">наименования классов представляют собой описательные названия свойств, не описывая семантическую сущность элемента, что иногда может усложнить разработку;</font></li>
                <li><font size="4">настройки отображения элементов переносятся непосредственно в HTML (это не то, для чего были придуманы таблицы стилей, не так ли?).</font></li>
            </ul> 
            <p> 
                <font size="4">
                В связи с этими недостатками, подход был встречен существенным объемом критики. Тем не менее, подход может оказаться эффективным для очень больших проектов — кажется, Yahoo! вполне довольны использованием ACSS (ссылка на интересную презентацию того же Тьерри Коблентца).
                Кроме того, атомарный CSS используется в различных фреймворках для задания корректирующих стилей элементов и в некоторых слоях других методологий. 
                </font>
            </p>
            <figure>
                <img src="../images/atomiccss.png" width="500" height="200" alt="">
                <figcaption><font size="4"><i>Рисунок 5 - <b>Atomic CSS</b></i></font></figcaption>
            </figure>
        </article>
        <section>
            <h2 id="part5">MCSS</h2>
        </section>
        <article contenteditable>
            <p> 
                <font size="4">
                MCSS — многослойный CSS (Multilayer CSS). Этот стиль написания кода, зародившийся в компании «Одноклассники», предлагает разделить стили на несколько частей, называемых слоями.
                </font>
            </p>
            <ul>
                <li><font size="4">Нулевой слой или фундамент — здесь содержится код, отвечающий за сброс стилей браузера (reset.css/normalize.css);</font></li>
                <li><font size="4">Базовый слой — включает в себя стили многократно используемых на сайте элементов: кнопок, полей ввода для текста, подсказок и т.п.;</font></li>
                <li><font size="4">Проектный слой — включает в себя отдельные модули, а также т.н. «контекст» — модификации элементов в зависимости от браузера клиента, устройства, на котором просматривается сайт/приложение, роли пользователя и т.п.;</font></li>
                <li><font size="4">Косметический слой — в этом разделе находится код, написанный в стиле OOCSS, осуществляющий мелкие изменения в внешнем виде элементов. Здесь рекомендуется оставлять только стили, влияющие на внешний вид и не способные поломать верстку сайта — цвета, некоторые некритичные отступы.</font></li>
            </ul> 
            <p> 
                <font size="4">
                Очень важна иерархия взаимодействия слоев:
                </font>                             
            </p>
            <ul>
                <li><font size="4">Слой фундамента задает нейтральные стили и не влияет на другие слои.</font></li>
                <li><font size="4">Элементы базового слоя могут влиять только на классы своего же слоя. Пример: иконки на сайте могут иметь размеры 25x25, но иконки в кнопках — 16x16.</font></li>
                <li><font size="4">Элементы проектного слоя могут влиять на базовый и проектный слой. Примеры: иконки в форме логина имеют особый размер 20x20; модуль «Покупка» может включать в себя форму логина, стили которой несколько модифицированы.</font></li>
                <li><font size="4">Косметический слой оформлен в виде описательных OOCSS-классов («атомарные» классы) и не влияет на другой CSS-код, избирательно применяясь в разметке.</font></li>
            </ul>
            <figure>
                <img src="../images/mcss.png" width="500" height="200" alt="">
                <figcaption><font size="4"><i>Рисунок 6 - <b>MCSS</b></i></font></figcaption>
            </figure>
        </article>
        <section>
            <h2 id="part6">AMCSS</h2>
        </section>
        <article contenteditable>
            <p> 
                <font size="4">
                Название подхода означает «Модули атрибутов для CSS» (Attribute Modules for CSS). Это достаточно необычный подход, упоминания которого, тем не менее, все чаще встречаются в блогах гуру разработки.
                </font>
            </p>
            <p> 
                <font size="4">
                Если обобщить, этот способ является несколько более человеко-читаемым представлением БЭМ-структуры. Давайте рассмотрим пример:
                </font>
            </p>
            <pre>
                <font size="4">   
                &lt;div class="button button--large button--blue"&gt;нопка&lt;/div&gt;
                </font>
            </pre>
            <p> 
                <font size="4">
                Такая цепочка классов не очень приятна для глаз, поэтому давайте сгруппируем эти значения по атрибутам.
                </font>
            </p>
            <p> 
                <font size="4">
                Вот что получится:
                </font>
            </p>
            <pre>
                <font size="4">   
                &lt;div button="large blue"&gt;Кнопка&lt;/div&gt;
                </font>
            </pre>
            <p> 
                <font size="4">
                Во избежание коллизий имен неплохо бы добавить атрибутам неймспейсы, не так ли? Тогда код нашей кнопки примет следующий вид:
                </font>
            </p>
            <pre>
                <font size="4">   
                &lt;div am-button="large blue"&gt;Кнопка&lt;/div&gt;
                </font>
            </pre>

            Если вы используете валидатор для проверки кода на корректность, не забывайте также добавить приставку «data-» перед названием атрибута.

            Для записи CSS-кода используется малоизвестный селектор «~=» (IE7+), который работает как атрибут класса: выбирает элементы, значения атрибутов которых содержат указанные слова, разделенные пробелами. Так, селектор вида a[class~=«link»][class~=«button»] аналогичен селектору a.class.button (даже по специфичности, так как специфичности селекторов по классу и по атрибуту равны друг другу!).

            Соответственно, CSS-код

            <pre>
                <font size="4">   
                .button {...}
                .button--large {...}
                .button--blue{...}
                </font>
            </pre>
            <p> 
                <font size="4">
                Преобразуется в 
                </font>
            </p>
            <pre>
                <font size="4">   
                [am-button] {...}
                [am-button~="large"] {...}
                [am-button~="blue"] {...}
                </font>
            </pre>
            <p> 
                <font size="4">
                Ну как? Если вы считаете такой код слишком оригинальным, для вас существует менее радикальная форма использования AMCSS:
                </font>
            </p>
            <pre>
                <font size="4">
                &lt;div am-button am-button-large am-button-blue&gt;&lt;/div&gt;
                </font>
            </pre>
            <figure>
                <img src="../images/amcss.png" width="500" height="200" alt="">
                <figcaption><font size="4"><i>Рисунок 7 - <b>AMCSS</b></i></font></figcaption>
            </figure>
        </article>
        <section>
            <h2 id="part7">FUN</h2>
        </section>
        <article contenteditable>
            <p> 
                <font size="4">
                FUN означает «плоская иерархия селекторов, служебные стили, компоненты с неймспейсами» (Flat hierarchy of selectors, Utility styles, Name-spaced components). Ну или веселье =)
                </font>
            </p>
            <p> 
                <font size="4">
                За каждой буквой названия стоит определенный принцип:
                </font>
            </p>

            <ul>
                <li><font size="4">F, плоская иерархия селекторов: в стилях рекомендуется использовать классы для выбора элементов, не вкладывать селекторы (избегать каскада без необходимости), а также не использовать id (если вы читали раздел БЭМ, вспомните про котят);</font></li>
                <li><font size="4">U, служебные классы: поощряется создание служебных атомарных стилей для решения типовых задач верстки, например, w100 для «width: 100%» или fr для «float: right»;</font></li>
                <li><font size="4">N, компоненты с неймспейсами: Бен рекомендует добавлять неймспейсы для задания стилей элементов конкретных модулей; такой подход позволит избежать совпадений в названиях классов.</font></li>
            </ul> 

            <p> 
                <font size="4">
                Некоторые разработчики отмечают, что код, написанный с использованием этих принципов достаточно удобно писать и поддерживать; в некотором роде автор взял лучшее от БЭМ и SMACSS и изложил эти техники в простой и лаконичной форме.
                </font>
            </p>
            <p> 
                <font size="4">
                Такой подход накладывает достаточно мало требований по структуре кода и проекта, он лишь устанавливает предпочтительную форму записи селекторов и способ их использования в разметке. Но в небольших проектах этих правил может быть вполне достаточно для создания качественного кода.
                </font>
            </p>
            <figure>
                <img src="../images/fun.png" width="500" height="200" alt="">
                <figcaption><font size="4"><i>Рисунок 8 - <b>FUN</b></i></font><</figcaption>
            </figure>
        </article>
        <aside>
            <br><br><br><div align="center"><a href="../content.html">Перейти к содержанию</a></div>
        </aside>
        <footer>
            <p align="center">Нижний Новгород, 2017</p>
        </footer>
    </body>
</html>